#!/usr/bin/env python3
"""
mixer_spur_replot.py

Re-plot mixer spur sweep results with clearly differentiated spurs.

- Reads the aggregated master CSV created by mixer_spur_sweep.py
- Groups data by spur expression (e.g. "1*LO + 2*IF")
- Plots RF frequency [GHz] vs level [dBc vs desired]
- Uses different colors/markers per expression
- Places legend outside the main axes (to the right)
- Allows thinning of markers so dense sweeps don't look like a blob

Usage example:

    uv run mixer_spur_replot.py \
        --in-dir spur_sweep_results \
        --master-csv ltc5553_5p83g_if_sweep_master.csv \
        --plot-png ltc5553_5p83g_if_sweep_spurs_improved.png \
        --marker-stride 10 \
        --max-exprs 25

Requirements:
    pip install matplotlib numpy
    The master CSV must have been generated by mixer_spur_sweep.py
"""

import argparse
import csv
from collections import defaultdict
from pathlib import Path
from typing import Dict, List, Tuple

import matplotlib.pyplot as plt
import numpy as np


# ---------------------------------------------------------------------------
# CSV loading & grouping
# ---------------------------------------------------------------------------

def load_master_csv(path: Path) -> List[dict]:
    """Load master CSV into a list of dict rows."""
    if not path.exists():
        raise FileNotFoundError(f"Master CSV not found: {path}")

    rows: List[dict] = []
    with path.open("r", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            rows.append(row)
    if not rows:
        raise RuntimeError(f"No data rows found in master CSV: {path}")
    return rows


def group_by_expression(
    rows: List[dict],
    include_desired: bool = False,
) -> Tuple[Dict[str, List[Tuple[float, float]]], Dict[str, dict]]:
    """
    Group points by spur expression.

    Returns:
        expr_points: {expression: [(freq_GHz, rel_dBc), ...]}
        expr_meta:   {expression: {"worst_dbc": float}}
    """
    expr_points: Dict[str, List[Tuple[float, float]]] = defaultdict(list)
    expr_meta: Dict[str, dict] = {}

    for row in rows:
        kind = row.get("kind", "")
        if not include_desired and kind == "desired":
            continue

        expr = row.get("expression", "").strip()
        if expr == "":
            continue

        rel = row.get("rel_dBc_vs_desired", "")
        f_meas = row.get("measured_freq_Hz", "")

        if rel == "" or f_meas == "":
            continue

        try:
            rel_val = float(rel)
            f_val = float(f_meas)
        except ValueError:
            continue

        freq_ghz = f_val / 1e9
        expr_points[expr].append((freq_ghz, rel_val))

        # Track "worst" spur for sorting legend (closest to 0 dBc is worst)
        if expr not in expr_meta:
            expr_meta[expr] = {"worst_dbc": rel_val}
        else:
            # Higher dBc (less negative) is worse
            if rel_val > expr_meta[expr]["worst_dbc"]:
                expr_meta[expr]["worst_dbc"] = rel_val

    # Sort points within each expression by frequency for nicer plots
    for expr, pts in expr_points.items():
        pts.sort(key=lambda x: x[0])

    return expr_points, expr_meta


def extract_run_info(rows: List[dict]) -> str:
    """
    Extract rough run info for use in the plot title:
    LO frequency, IF sweep range, mode.
    """
    lo_vals = []
    if_vals = []
    mode_vals = set()

    for row in rows:
        lo_s = row.get("lo_Hz", "")
        if_s = row.get("if_Hz", "")
        mode_s = row.get("mode", "")

        try:
            if lo_s != "":
                lo_vals.append(float(lo_s))
        except ValueError:
            pass

        try:
            if if_s != "":
                if_vals.append(float(if_s))
        except ValueError:
            pass

        if mode_s:
            mode_vals.add(mode_s)

    title_parts = []

    if lo_vals:
        lo_ghz = np.mean(lo_vals) / 1e9
        title_parts.append(f"LO ≈ {lo_ghz:.3f} GHz")

    if if_vals:
        if_min_ghz = min(if_vals) / 1e9
        if_max_ghz = max(if_vals) / 1e9
        title_parts.append(f"IF {if_min_ghz:.3f}–{if_max_ghz:.3f} GHz")

    if mode_vals:
        # If multiple modes are present, just show them comma-separated
        modes_str = ", ".join(sorted(mode_vals))
        title_parts.append(f"mode: {modes_str}")

    if title_parts:
        return " | ".join(title_parts)
    else:
        return "Mixer spur sweep"


# ---------------------------------------------------------------------------
# Plotting
# ---------------------------------------------------------------------------

def make_spur_plot(
    rows: List[dict],
    out_path: Path,
    include_desired: bool = False,
    marker_stride: int = 10,
    max_exprs: int = 0,
) -> None:
    """Create improved spur plot and save to out_path."""

    if marker_stride < 1:
        marker_stride = 1

    expr_points, expr_meta = group_by_expression(
        rows, include_desired=include_desired
    )

    if not expr_points:
        raise RuntimeError("No valid spur points to plot.")

    # Sort expressions by worst-case dBc (descending: worst at top)
    sorted_exprs = sorted(
        expr_points.keys(),
        key=lambda e: expr_meta[e]["worst_dbc"],
        reverse=True,
    )

    # Optionally keep only the top-N worst expressions (for readability)
    if max_exprs and max_exprs > 0:
        sorted_exprs = sorted_exprs[:max_exprs]

    # Simple, explicit style cycles
    color_cycle = [
        "tab:blue",
        "tab:orange",
        "tab:green",
        "tab:red",
        "tab:purple",
        "tab:brown",
        "tab:pink",
        "tab:gray",
        "tab:olive",
        "tab:cyan",
    ]
    marker_cycle = ["o", "s", "^", "v", "D", "P", "X", "*", "<", ">", "h", "H"]
    line_styles = ["-", "--", "-.", ":"]

    fig, ax = plt.subplots(figsize=(12, 7))

    all_freqs: List[float] = []
    all_dbc: List[float] = []

    print(f"Number of spur expressions to plot: {len(sorted_exprs)}")

    for idx, expr in enumerate(sorted_exprs):
        pts = expr_points.get(expr, [])
        if not pts:
            continue

        x = [p[0] for p in pts]  # freq GHz
        y = [p[1] for p in pts]  # dBc

        all_freqs.extend(x)
        all_dbc.extend(y)

        x_sparse = x[::marker_stride]
        y_sparse = y[::marker_stride]

        color = color_cycle[idx % len(color_cycle)]
        marker = marker_cycle[idx % len(marker_cycle)]
        linestyle = line_styles[idx % len(line_styles)]

        # For debugging / sanity check
        print(f"  expr[{idx}]: '{expr}' -> color={color}, marker={marker}, ls={linestyle}")

        # Connect all points with a thin line
        ax.plot(
            x,
            y,
            color=color,
            linestyle=linestyle,
            linewidth=0.7,
            alpha=0.9,
        )

        # Thinned markers: only every Nth point
        ax.scatter(
            x_sparse,
            y_sparse,
            label=expr,
            color=color,
            marker=marker,
            s=20,
            alpha=0.9,
        )

    ax.set_xlabel("RF frequency [GHz]")
    ax.set_ylabel("Level [dBc vs desired]")
    ax.grid(True, which="both", linestyle="--", linewidth=0.5, alpha=0.7)

    # Invert y-axis so "better" (more negative) spurs are downwards
    if all_dbc:
        #y_min = min(all_dbc)
        #y_max = max(all_dbc)
        y_min = -120
        y_max = 0
        #y_margin = 0.05 * (y_max - y_min or 1.0)
        y_margin = 0
        ax.set_ylim(y_min - y_margin, y_max + y_margin)
        ax.set_yticks(range(int(y_min), int(y_max) + 1, 10))
        ax.invert_yaxis()
    else:
        ax.invert_yaxis()
    
    # Set x-axis to log scale
    #ax.set_xscale("log")

    # Set plot title from run info
    #title = extract_run_info(rows)
    title = "HMC329 - Mode: IF + LO 23 GHz - IF 6.5 GHz to 8.0 GHz"
    ax.set_title(title)

    # Tighten x-limits a bit
    if all_freqs:
        x_min = 25
        x_max = 35
        #x_min = min(all_freqs)
        #x_max = max(all_freqs)
        x_margin = 0.02 * (x_max - x_min or 1.0)
        ax.set_xlim(x_min - x_margin, x_max + x_margin)
        ax.set_xticks(range(int(x_min), int(x_max) + 1, 1))

    # Legend outside to the right
    legend_fontsize = 8 if len(sorted_exprs) > 10 else 9

    # Reserve space on the right for the legend with tight_layout
    fig.tight_layout(rect=(0.0, 0.0, 0.88, 1.0))

    ax.legend(
        loc="center left",
        bbox_to_anchor=(1.02, 0.5),
        borderaxespad=0.0,
        fontsize=legend_fontsize,
        title="Spur Expression",
        #ncol=2
    )

    fig.savefig(out_path, dpi=200)
    plt.close(fig)

    print(f"Improved spur plot saved to: {out_path}")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Re-plot mixer spur sweep results with per-spur colors + legend."
    )
    parser.add_argument(
        "--in-dir",
        default="spur_sweep_results",
        help="Directory containing the master CSV (default: spur_sweep_results).",
    )
    parser.add_argument(
        "--master-csv",
        default="spur_sweep_master.csv",
        help="Name of aggregated CSV inside in-dir (default: spur_sweep_master.csv).",
    )
    parser.add_argument(
        "--plot-png",
        default="spur_sweep_spurs_improved.png",
        help="Output PNG filename inside in-dir (default: spur_sweep_spurs_improved.png).",
    )
    parser.add_argument(
        "--include-desired",
        action="store_true",
        help="Include the desired mixer product in the plot (default: only spurs).",
    )
    parser.add_argument(
        "--marker-stride",
        type=int,
        default=10,
        help="Plot a marker only every Nth point per expression (default: 10).",
    )
    parser.add_argument(
        "--max-exprs",
        type=int,
        default=0,
        help=(
            "Maximum number of spur expressions to plot (0 = all, default: 0). "
            "Expressions are sorted by worst-case dBc (worst first)."
        ),
    )

    args = parser.parse_args()

    in_dir = Path(args.in_dir)
    master_csv_path = in_dir / args.master_csv
    plot_path = in_dir / args.plot_png

    print(f"Loading master CSV from: {master_csv_path}")
    rows = load_master_csv(master_csv_path)

    print("Building improved spur plot...")
    make_spur_plot(
        rows,
        out_path=plot_path,
        include_desired=args.include_desired,
        marker_stride=args.marker_stride,
        max_exprs=args.max_exprs,
    )

    print("Done.")


if __name__ == "__main__":
    main()
